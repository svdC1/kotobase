{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kotobase","text":""},{"location":"#_1","title":"","text":"<p>Kotobase is a Japanese language Python package which provides simple programmatic access to various data sources via a pre-built database which is updated weekly via a GitHub action.</p>"},{"location":"#data-sources","title":"Data Sources","text":"<p>Kotobase uses data from these sources to build its Database.</p> <ul> <li> <p><code>JMDict</code> : Japanese-Multilingual Dictionary.</p> </li> <li> <p><code>JMnedict</code> : A dictionary of Japanese proper names.</p> </li> <li> <p><code>KanjiDic2</code> : A comprehensive kanji dictionary.</p> </li> <li> <p><code>Tatoeba</code> : A large database of example sentences.</p> </li> <li> <p><code>JLPT Lists</code> : Curated list of Grammar, Vocabulary and Kanji separated by Japanese Language Proficiency Test levels, made available on Jonathan Weller's website.</p> </li> </ul>"},{"location":"#licenses","title":"Licenses","text":"<p>The licenses of these data sources and the NOTICE is available at <code>docs/licenses</code> in this repository.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Comprehensive Lookups \u2192 Search for words (kanji, kana, or romaji), kanji, and proper names.</p> </li> <li> <p>Organized Data \u2192 Get detailed information including readings, senses, parts of speech, kanji stroke counts, meanings, and JLPT levels formatted into Python Data Objects.</p> </li> <li> <p>Example Sentences \u2192 Find example sentences from Tatoeba that contain the searched query.</p> </li> <li> <p>Wildcard Search \u2192 Use <code>*</code> or <code>%</code> for wildcard searches.</p> </li> <li> <p>Command-Line Interface \u2192 User-friendly CLI for quick lookups from the terminal.</p> </li> <li> <p>Self-Contained \u2192 All data is stored in a local SQLite database, so it's fast and works offline.</p> </li> <li> <p>Easy Database Management \u2192 Includes commands to automatically download the latest pre-built database from the public Drive or download source files and build the database locally.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<ul> <li>Install the package</li> </ul> <pre><code>pip install kotobase\n</code></pre> <p>This will install the <code>kotobase</code> package and its dependencies, and it will also make the <code>kotobase</code> command-line tool available in your shell.</p> <ul> <li>Pull the Database from Drive or Build it locally by running of the commands below in the environment you installed kotobase</li> </ul> <pre><code># Pull from Drive\nkotobase pull-db\n# Build locally\nkotobase build\n</code></pre> <p>The database will be downloaded or built internally in the package at <code>kotobase/src/db/kotobase.db</code> and will be available for use.</p>"},{"location":"API/","title":"API","text":""},{"location":"API/#kotobase.api","title":"<code>api</code>","text":"<p>This module defines the main kotobase API through the <code>Kotobase</code> class to make queries to the database and return data objects.</p>"},{"location":"API/#kotobase.api.Kotobase","title":"<code>Kotobase</code>","text":"<p>Stateless class that orchestrates the individual repositories and returns serialisable objects.</p>"},{"location":"API/#kotobase.api.Kotobase.__call__","title":"<code>__call__(word, *, wildcard=False, include_names=False, sentence_limit=50, entry_limit=None)</code>","text":"<p>Comprehensive word lookup.</p> <p>Parameters:</p> Name Type Description Default <code>word</code> <code>str</code> <p>The query string (kana, kanji)           Supports SQL wildcards '*' or '%'.</p> required <code>wildcard</code> <code>bool</code> <p>If True, passes wildcards through unchanged.                If False, the search is exact (JMdict) but                Tatoeba uses <code>%word%</code> containment.</p> <code>False</code> <code>include_names</code> <code>bool</code> <p>Also query JMnedict (proper names).                     Can be slow on very broad wildcards.</p> <code>False</code> <code>sentence_limit</code> <code>int</code> <p>Maximum number of Tatoeba sentences to fetch.</p> <code>50</code> <code>entry_limit</code> <code>int</code> <p>Maximum number of entries to fetch.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>LookupResult</code> <code>LookupResult</code> <p>LookupResult Object.</p>"},{"location":"API/#kotobase.api.Kotobase.db_info","title":"<code>db_info()</code>  <code>staticmethod</code>","text":"<p>Return a dictionary containing variables from Database build log file, if it exists.</p> <p>Raises:</p> Type Description <code>EnvironmentError</code> <p>If file doeesn't exist.</p>"},{"location":"API/#kotobase.api.Kotobase.jlpt_level","title":"<code>jlpt_level(word)</code>  <code>staticmethod</code>","text":"<p>Shortcut \u2013 just return JLPT vocab level for a word.</p> <p>Parameters:</p> Name Type Description Default <code>word</code> <code>str</code> <p>Word to search for.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>Optional[int]</code> <p>The JLPT Level</p>"},{"location":"API/#kotobase.api.Kotobase.kanji","title":"<code>kanji(literal)</code>  <code>staticmethod</code>","text":"<p>Return a single KanjiDTO (or None).</p> <p>Parameters:</p> Name Type Description Default <code>literal</code> <code>str</code> <p>Kanji Literal String.</p> required <p>Returns:</p> Name Type Description <code>KanjiDTO</code> <code>Optional[KanjiDTO]</code> <p>Kanji data object</p>"},{"location":"API/#kotobase.api.Kotobase.lookup","title":"<code>lookup(word, *, wildcard=False, include_names=False, sentence_limit=50, entry_limit=None)</code>","text":"<p>Comprehensive word lookup.</p> <p>Parameters:</p> Name Type Description Default <code>word</code> <code>str</code> <p>The query string (kana, kanji)           Supports SQL wildcards '*' or '%'.</p> required <code>wildcard</code> <code>bool</code> <p>If True, passes wildcards through unchanged.                If False, the search is exact (JMdict) but                Tatoeba uses <code>%word%</code> containment.</p> <code>False</code> <code>include_names</code> <code>bool</code> <p>Also query JMnedict (proper names).                     Can be slow on very broad wildcards.</p> <code>False</code> <code>sentence_limit</code> <code>int</code> <p>Maximum number of Tatoeba sentences to fetch.</p> <code>50</code> <code>entry_limit</code> <code>int</code> <p>Maximum number of entries to fetch.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>LookupResult</code> <code>LookupResult</code> <p>LookupResult Object.</p>"},{"location":"API/#kotobase.api.Kotobase.sentences","title":"<code>sentences(text, *, limit=20)</code>  <code>staticmethod</code>","text":"<p>Fetch Japanese Tatoeba sentences containing text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>String text to search for</p> required <code>limit</code> <code>int</code> <p>How many sentences to return.</p> <code>20</code>"},{"location":"CLI%20_Code/","title":"CLI  Code","text":""},{"location":"CLI%20_Code/#kotobase.cli","title":"<code>cli</code>","text":"<p>This module defines the kotobase CLI implementation using the Click module.</p>"},{"location":"CLI%20_Code/#kotobase.cli.db_info","title":"<code>db_info()</code>","text":"<p>Print information about Database being used.</p> Source code in <code>kotobase/src/kotobase/cli.py</code> <pre><code>@main.command()\ndef db_info():\n    \"\"\"\n    Print information about Database being used.\n    \"\"\"\n    try:\n        info = kb.db_info()\n        click.secho(\"--- Database Build Log ---\",\n                    fg=\"blue\")\n        click.secho(f\"Build Date : {info['build_date']}\")\n        click.secho(f\"Build Time : {info['build_time']} seconds\")\n        click.secho(f\"File Size : {info['size_mb']} MB\")\n\n    except Exception as e:\n        click.secho(f\"Error Getting Database Info: {e}\",\n                    fg=\"red\",\n                    err=True\n                    )\n        sys.exit(1)\n</code></pre>"},{"location":"CLI%20_Code/#kotobase.cli.jlpt","title":"<code>jlpt(word)</code>","text":"<p>Show JLPT levels associated with a word / kanji string.</p> Source code in <code>kotobase/src/kotobase/cli.py</code> <pre><code>@main.command()\n@click.argument(\"word\")\ndef jlpt(word: str):\n    \"\"\"\n    Show JLPT levels associated with a word / kanji string.\n    \"\"\"\n    try:\n        vocab_level = kb.jlpt_level(word)\n        kanji_levels = kb.lookup(word).jlpt_kanji_levels\n        if vocab_level:\n            click.echo(f\"Vocabulary level: N{vocab_level}\")\n        else:\n            click.echo(\"Vocabulary: (not in JLPT lists)\")\n\n        if kanji_levels:\n            click.echo(\"Kanji levels:\")\n            for k, lvl in kanji_levels.items():\n                click.echo(f\"  {k} -&gt; N{lvl}\")\n        else:\n            click.echo(\"Kanji: (none in JLPT lists)\")\n    except Exception as e:\n        click.secho(f\"Error During Lookup: {e}\",\n                    fg=\"red\",\n                    err=True\n                    )\n        sys.exit(1)\n</code></pre>"},{"location":"CLI%20_Code/#kotobase.cli.kanji","title":"<code>kanji(literal)</code>","text":"<p>Show KanjiDic details for a single character.</p> Source code in <code>kotobase/src/kotobase/cli.py</code> <pre><code>@main.command()\n@click.argument(\"literal\")\ndef kanji(literal: str):\n    \"\"\"\n    Show KanjiDic details for a single character.\n    \"\"\"\n    try:\n        info = kb.kanji(literal)\n        if not info:\n            click.echo(\"Kanji not found.\")\n            return\n        handle_kanji(info)\n    except Exception as e:\n        click.secho(f\"Error During Lookup: {e}\",\n                    fg=\"red\",\n                    err=True\n                    )\n        sys.exit(1)\n</code></pre>"},{"location":"CLI%20_Code/#kotobase.cli.lookup","title":"<code>lookup(word, names, wildcard, sentences, json_out)</code>","text":"<p>Comprehensive dictionary lookup.</p> Source code in <code>kotobase/src/kotobase/cli.py</code> <pre><code>@main.command()\n@click.argument(\"word\")\n@click.option(\"-n\",\n              \"--names\",\n              is_flag=True,\n              help=\"Include JMnedict names\"\n              )\n@click.option(\"-w\",\n              \"--wildcard\",\n              is_flag=True,\n              help=\"Treat '*'/'%' as wildcards\"\n              )\n@click.option(\"-s\",\n              \"--sentences\",\n              default=5,\n              show_default=True,\n              help=\"Number of example sentences to display (0 = none)\"\n              )\n@click.option(\"--json-out\",\n              \"-j\",\n              is_flag=True,\n              help=\"Dump raw JSON result\"\n              )\ndef lookup(word: str,\n           names: bool,\n           wildcard: bool,\n           sentences: int,\n           json_out: bool\n           ):\n    \"\"\"\n    Comprehensive dictionary lookup.\n    \"\"\"\n    try:\n        result = kb.lookup(word,\n                           wildcard=wildcard,\n                           include_names=names,\n                           sentence_limit=sentences)\n\n        if json_out:\n            click.echo(result.to_json())\n            return\n\n        # ---------- JMdict / JMnedict ----------\n        click.secho(\"\\n[Dictionary Entries]\", fg=\"cyan\", bold=True)\n        if result.entries:\n            for ent in result.entries:\n                if isinstance(ent, JMDictEntryDTO):\n                    handle_jmdict(ent)\n                elif isinstance(ent, JMNeDictEntryDTO):\n                    handle_jmnedict(ent)\n        else:\n            click.echo(\"No Entries\")\n\n        # ---------- Kanji ----------\n        if result.kanji:\n            click.secho(\"\\n[Kanji Breakdown]\", fg=\"cyan\", bold=True)\n            for kan in result.kanji:\n                handle_kanji(kan)\n\n        # ---------- JLPT vocab ----------\n        if result.jlpt_vocab:\n            click.secho(\"\\n[Tanos JLPT Vocabulary]\", fg=\"cyan\", bold=True)\n            handle_jlpt_vocab(result.jlpt_vocab)\n\n        # ---------- JLPT grammar ----------\n        if result.jlpt_grammar:\n            click.secho(\"\\n[Tanos JLPT Grammar]\", fg=\"cyan\", bold=True)\n            for g in result.jlpt_grammar:\n                handle_jlpt_grammar(g)\n        # ---------- Sentences ----------\n        if sentences:\n            click.secho(\"\\n[Example Sentences]\", fg=\"cyan\", bold=True)\n            if result.examples:\n                for sen in result.examples[:sentences]:\n                    bullet(sen.text)\n            else:\n                click.echo(\"No Examples Found\")\n    except Exception as e:\n        click.secho(f\"Error During Lookup: {e}\",\n                    fg=\"red\",\n                    err=True\n                    )\n        sys.exit(1)\n</code></pre>"},{"location":"CLI/","title":"CLI","text":"<p>The <code>kotobase</code> command provides several subcommands for different types of lookups.</p>"},{"location":"CLI/#general-lookup","title":"General Lookup","text":"<p>The <code>lookup</code> command is the most comprehensive way to search for a word.</p> <pre><code>kotobase lookup \u65e5\u672c\u8a9e\n</code></pre> <p>This will show you dictionary entries, kanji information, JLPT levels, and example sentences for the word \"\u65e5\u672c\u8a9e\".</p> <p>Options:</p> <ul> <li><code>-n</code>, <code>--names</code>: Include proper names from JMnedict in the search.</li> <li><code>-w</code>, <code>--wildcard</code>: Treat <code>*</code> or <code>%</code> as wildcards in the search term.</li> <li><code>-s</code>, <code>--sentences</code>: Specify the number of example sentences to show.</li> <li><code>--json-out</code>: Output the full results as a JSON object.</li> </ul>"},{"location":"CLI/#kanji-lookup","title":"Kanji Lookup","text":"<p>To get information about a specific kanji character:</p> <pre><code>kotobase kanji \u8a9e\n</code></pre> <p>This will display the kanji's grade, stroke count, meanings, on'yomi, and kun'yomi readings, and JLPT level.</p>"},{"location":"CLI/#jlpt-lookup","title":"JLPT Lookup","text":"<p>To check the JLPT level for a word or kanji:</p> <pre><code>kotobase jlpt \u52c9\u5f37\n</code></pre>"},{"location":"CLI/#database","title":"Database","text":"<p>Kotobase relies on a local SQLite database.</p> <p>You can also build it from the source files yourself.</p> <p>The following commands are available for managing the database:</p> <pre><code>kotobase pull-db\n</code></pre> <p>Downloads the pre-built SQLite database from a public <code>Google Drive Folder</code>. This file is overwritten every week with a rebuilt database from updated sources. The rebuilding and overwriting is managed by a GitHub action in this repository.</p> <pre><code>kotobase build\n</code></pre> <p>Builds the SQLite database from the raw source files. This will download the latest version of the source files (Except Tanos JLPT lists which are shipped with the package itself.) and build the database locally.</p>"},{"location":"Data_Mappers/","title":"Data Mappers","text":""},{"location":"Data_Mappers/#kotobase.core.datatypes","title":"<code>datatypes</code>","text":"<p>This module defines the <code>kotobase</code> datatypes representing information from the different data sources.</p>"},{"location":"Data_Mappers/#kotobase.core.datatypes.map_jmdict","title":"<code>map_jmdict(entry)</code>","text":"<p>Map Raw JMDictEntry database row to a Python DTO.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>JMDictEntry</code> <p>SQLAlchemy Table object</p> required <p>Returns:</p> Name Type Description <code>JMDictEntryDTO</code> <code>JMDictEntryDTO</code> <p>Python DTO</p> Source code in <code>kotobase/src/kotobase/core/datatypes.py</code> <pre><code>def map_jmdict(entry: orm.JMDictEntry) -&gt; JMDictEntryDTO:\n    \"\"\"\n    Map Raw JMDictEntry database row to a Python DTO.\n\n    Args:\n      entry (JMDictEntry): SQLAlchemy Table object\n\n    Returns:\n      JMDictEntryDTO: Python DTO\n\n    \"\"\"\n    return JMDictEntryDTO(\n        id=entry.id,\n        rank=entry.rank,\n        kana=[k.text for k in entry.kana],\n        kanji=[k.text for k in entry.kanji],\n        senses=[\n            {\n                \"order\": s.order,\n                \"pos\":   s.pos,\n                \"gloss\": s.gloss,\n            }\n            for s in entry.senses\n        ],\n    )\n</code></pre>"},{"location":"Data_Mappers/#kotobase.core.datatypes.map_jmnedict","title":"<code>map_jmnedict(entry)</code>","text":"<p>Map Raw JMNeDictEntry database row to a Python DTO.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>JMneDictEntry</code> <p>SQLAlchemy Table object</p> required <p>Returns:</p> Name Type Description <code>JMNeDictEntryDTO</code> <code>JMNeDictEntryDTO</code> <p>Python DTO</p> Source code in <code>kotobase/src/kotobase/core/datatypes.py</code> <pre><code>def map_jmnedict(entry: orm.JMnedictEntry) -&gt; JMNeDictEntryDTO:\n    \"\"\"\n    Map Raw JMNeDictEntry database row to a Python DTO.\n\n    Args:\n      entry (JMneDictEntry): SQLAlchemy Table object\n\n    Returns:\n      JMNeDictEntryDTO: Python DTO\n\n    \"\"\"\n    return JMNeDictEntryDTO(\n        id=entry.id,\n        kana=_split_list(entry.kana,  sep=\";\"),\n        kanji=_split_list(entry.kanji, sep=\";\"),\n        translation_type=entry.translation_type,\n        gloss=_split_list(entry.translation, sep=\";\"),\n    )\n</code></pre>"},{"location":"Data_Mappers/#kotobase.core.datatypes.map_jlpt_vocab","title":"<code>map_jlpt_vocab(row)</code>","text":"<p>Map Raw JLPT Vocabulary database row to a Python DTO.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>JlptVocab</code> <p>SQLAlchemy Table object</p> required <p>Returns:</p> Name Type Description <code>JLPTVocabDTO</code> <code>JLPTVocabDTO</code> <p>Python DTO</p> Source code in <code>kotobase/src/kotobase/core/datatypes.py</code> <pre><code>def map_jlpt_vocab(row: orm.JlptVocab) -&gt; JLPTVocabDTO:\n    \"\"\"\n    Map Raw JLPT Vocabulary database row to a Python DTO.\n\n    Args:\n      entry (JlptVocab): SQLAlchemy Table object\n\n    Returns:\n      JLPTVocabDTO: Python DTO\n\n    \"\"\"\n    return JLPTVocabDTO(\n        id=row.id,\n        level=row.level,\n        kanji=row.kanji,\n        hiragana=row.hiragana,\n        english=row.english,\n    )\n</code></pre>"},{"location":"Data_Mappers/#kotobase.core.datatypes.map_jlpt_kanji","title":"<code>map_jlpt_kanji(row)</code>","text":"<p>Map Raw JLPT Kanji database row to a Python DTO.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>JlptKanji</code> <p>SQLAlchemy Table object</p> required <p>Returns:</p> Name Type Description <code>JLPTKanjiDTO</code> <code>JLPTKanjiDTO</code> <p>Python DTO</p> Source code in <code>kotobase/src/kotobase/core/datatypes.py</code> <pre><code>def map_jlpt_kanji(row: orm.JlptKanji) -&gt; JLPTKanjiDTO:\n    \"\"\"\n    Map Raw JLPT Kanji database row to a Python DTO.\n\n    Args:\n      entry (JlptKanji): SQLAlchemy Table object\n\n    Returns:\n      JLPTKanjiDTO: Python DTO\n\n    \"\"\"\n    return JLPTKanjiDTO(\n        id=row.id,\n        level=row.level,\n        kanji=row.kanji,\n    )\n</code></pre>"},{"location":"Data_Mappers/#kotobase.core.datatypes.map_jlpt_grammar","title":"<code>map_jlpt_grammar(row)</code>","text":"<p>Map Raw JLPT Grammar database row to a Python DTO.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>JlptGrammar</code> <p>SQLAlchemy Table object</p> required <p>Returns:</p> Name Type Description <code>JLPTGrammarDTO</code> <code>JLPTGrammarDTO</code> <p>Python DTO</p> Source code in <code>kotobase/src/kotobase/core/datatypes.py</code> <pre><code>def map_jlpt_grammar(row: orm.JlptGrammar) -&gt; JLPTGrammarDTO:\n    \"\"\"\n    Map Raw JLPT Grammar database row to a Python DTO.\n\n    Args:\n      entry (JlptGrammar): SQLAlchemy Table object\n\n    Returns:\n      JLPTGrammarDTO: Python DTO\n\n    \"\"\"\n    return JLPTGrammarDTO(\n        id=row.id,\n        level=row.level,\n        grammar=row.grammar,\n        formation=row.formation,\n        examples=_split_list(row.examples, sep=\"|\"),\n    )\n</code></pre>"},{"location":"Data_Mappers/#kotobase.core.datatypes.map_kanjidic","title":"<code>map_kanjidic(row, *, jlpt_tanos_level=None)</code>","text":"<p>Map Raw KANJIDIC2 database row to a Python DTO.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Kanjidic</code> <p>SQLAlchemy Table object</p> required <code>jlpt_tanos_level</code> <code>int</code> <p>JLPT level extracted from Tanos lists                                 if it exists.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>KanjiDTO</code> <code>KanjiDTO</code> <p>Python DTO</p> Source code in <code>kotobase/src/kotobase/core/datatypes.py</code> <pre><code>def map_kanjidic(\n    row: orm.Kanjidic,\n    *,\n    jlpt_tanos_level: Optional[int] = None,\n) -&gt; KanjiDTO:\n    \"\"\"\n    Map Raw KANJIDIC2 database row to a Python DTO.\n\n    Args:\n      row (Kanjidic): SQLAlchemy Table object\n      jlpt_tanos_level (int, optional): JLPT level extracted from Tanos lists\n                                        if it exists.\n\n    Returns:\n      KanjiDTO: Python DTO\n    \"\"\"\n    return KanjiDTO(\n        literal=row.literal,\n        grade=row.grade,\n        stroke_count=row.stroke_count,\n        meanings=_split_list(row.meanings, sep=\",\"),\n        onyomi=_split_list(row.on_readings, sep=\",\"),\n        kunyomi=_split_list(row.kun_readings, sep=\",\"),\n        jlpt_kanjidic=row.jlpt,\n        jlpt_tanos=jlpt_tanos_level,\n    )\n</code></pre>"},{"location":"Data_Mappers/#kotobase.core.datatypes.map_sentence","title":"<code>map_sentence(row)</code>","text":"<p>Map Raw Tatoeba exmaple sentences database row to a Python DTO.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TatoebaSentence</code> <p>SQLAlchemy Table object</p> required <p>Returns:</p> Name Type Description <code>SentenceDTO</code> <code>SentenceDTO</code> <p>Python DTO</p> Source code in <code>kotobase/src/kotobase/core/datatypes.py</code> <pre><code>def map_sentence(row: orm.TatoebaSentence) -&gt; SentenceDTO:\n    \"\"\"\n    Map Raw Tatoeba exmaple sentences database row to a Python DTO.\n\n    Args:\n      entry (TatoebaSentence): SQLAlchemy Table object\n\n    Returns:\n      SentenceDTO: Python DTO\n    \"\"\"\n    return SentenceDTO(\n        id=row.id,\n        text=row.text,\n    )\n</code></pre>"},{"location":"Data_Mappers/#kotobase.core.datatypes.map_many","title":"<code>map_many(func, rows)</code>","text":"<p>Apply any single-row mapper across any iterable while keeping return order.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The mapper function to apply</p> required <code>rows</code> <code>Iterable</code> <p>The returned database rows</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>List</code> <p>List of the DTO objects returned by <code>func</code></p> Source code in <code>kotobase/src/kotobase/core/datatypes.py</code> <pre><code>def map_many(func: Callable,\n             rows: Iterable\n             ) -&gt; List:\n    \"\"\"\n    Apply any single-row mapper across any iterable while keeping return order.\n\n    Args:\n      func (Callable): The mapper function to apply\n      rows (Iterable): The returned database rows\n\n    Returns:\n      list: List of the DTO objects returned by `func`\n    \"\"\"\n    return [func(r) for r in rows]\n</code></pre>"},{"location":"Database_Tables/","title":"Database Tables","text":"<p>This module defines the <code>kotobase</code> database schema with <code>SQLAlchemy</code></p>"},{"location":"Database_Tables/#kotobase.db.models","title":"<code>models</code>","text":"<p>This module defines the <code>kotobase</code> database schema with <code>SQLAlchemy</code></p>"},{"location":"Database_Tables/#kotobase.db.models.JMDictEntry","title":"<code>JMDictEntry</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database JMDictEntry Table</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Row ID</p> <code>rank</code> <code>id</code> <p>Priority rank</p> <code>kanji</code> <code>relationship</code> <p>Relationship to JMDict Kanji Table</p> <code>kana</code> <code>relationship</code> <p>Relationship to JMDict Kana Table</p> <code>senses</code> <code>relationship</code> <p>Relationship to JMDict Senses Table</p>"},{"location":"Database_Tables/#kotobase.db.models.JMDictGlossFTS","title":"<code>JMDictGlossFTS</code>","text":"<p>               Bases: <code>Base</code></p> <p>FTS5 shadow table for entry sense gloss.</p> <p>Attributes:</p> Name Type Description <code>rowid</code> <code>int</code> <p>Row ID</p> <code>gloss</code> <code>str</code> <p>Entry sense gloss.</p>"},{"location":"Database_Tables/#kotobase.db.models.JMDictKana","title":"<code>JMDictKana</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database JMDictEntry Kana Table.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Row ID</p> <code>entry_id</code> <code>int</code> <p>Foreign key to JMDictEntry id</p> <code>order</code> <code>int</code> <p>Order of appearence</p> <code>text</code> <code>str</code> <p>Kana Text</p> <code>entry</code> <code>relationship</code> <p>Relationship to JMDict Entries</p>"},{"location":"Database_Tables/#kotobase.db.models.JMDictKanji","title":"<code>JMDictKanji</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database JMDict Kanji Table</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Row ID</p> <code>entry_id</code> <code>int</code> <p>Foreign key to JMDictEntry id</p> <code>order</code> <code>int</code> <p>Order of appearence</p> <code>text</code> <code>str</code> <p>Kanji Text</p> <code>entry</code> <code>relationship</code> <p>Relationship to JMDict Entries</p>"},{"location":"Database_Tables/#kotobase.db.models.JMDictSense","title":"<code>JMDictSense</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database JMDict Senses Table.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Row ID</p> <code>entry_id</code> <code>int</code> <p>Foreign Key to JMDict Entries Table ID</p> <code>order</code> <code>int</code> <p>Integer representing precedence of sense.</p> <code>pos</code> <code>str</code> <p>Part of Speech the entry sense belongs to.</p> <code>gloss</code> <code>str</code> <p>Gloss of the entry.</p> <code>entry</code> <code>relationship</code> <p>Relationship to JMDict Entries Table</p>"},{"location":"Database_Tables/#kotobase.db.models.JMnedictEntry","title":"<code>JMnedictEntry</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database JMNeDictEntry Table.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Row ID</p> <code>kanji</code> <code>str</code> <p>Kanji text</p> <code>kana</code> <code>str</code> <p>Kana text</p> <code>translation_type</code> <code>str</code> <p>Type of entry.</p> <code>translation</code> <code>Text</code> <p>English text</p>"},{"location":"Database_Tables/#kotobase.db.models.JlptGrammar","title":"<code>JlptGrammar</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database Tanos JLPT Grammar Table.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Row ID</p> <code>level</code> <code>int</code> <p>JLPT level of grammar point</p> <code>grammar</code> <code>str</code> <p>Grammar point itself</p> <code>formation</code> <code>str</code> <p>General formation of grammar point</p> <code>examples</code> <code>Text</code> <p>List of examples containing grammar point</p>"},{"location":"Database_Tables/#kotobase.db.models.JlptKanji","title":"<code>JlptKanji</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database Tanos JLPT Kanji Table.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Row ID</p> <code>level</code> <code>int</code> <p>Tanos JLPT level of Kanji</p> <code>kanji</code> <code>str</code> <p>Literal Kanji</p> <code>on_yomi</code> <code>str</code> <p>On'yomi of the Kanji</p> <code>kun_yomi</code> <code>str</code> <p>Kun'yomi of the Kanji</p> <code>english</code> <code>str</code> <p>English translation</p>"},{"location":"Database_Tables/#kotobase.db.models.JlptVocab","title":"<code>JlptVocab</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database Tanos JLPT Vocab List Table.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Row ID</p> <code>level</code> <code>int</code> <p>JLPT Level of the entry</p> <code>kanji</code> <code>str</code> <p>Kanji contained in the entry</p> <code>hiragana</code> <code>str</code> <p>Kana Reading of the entry</p> <code>english</code> <code>Text</code> <p>English translation of the entry</p>"},{"location":"Database_Tables/#kotobase.db.models.Kanjidic","title":"<code>Kanjidic</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database KANJIDIC2 Table.</p> <p>Attributes:</p> Name Type Description <code>literal</code> <code>str</code> <p>Kanji Literal</p> <code>grade</code> <code>int</code> <p>Japanese Grade in which Kanji is taught.</p> <code>stroke_count</code> <code>int</code> <p>Number of strokes in handwriting.</p> <code>jlpt</code> <code>int</code> <p>KANJIDIC2 JLPT classification.</p> <code>on_readings</code> <code>str</code> <p>On'yomi of Kanji</p> <code>kun_readings</code> <code>str</code> <p>Kun'yomi of Kanji</p> <code>meanings</code> <code>str</code> <p>List of meanings.</p>"},{"location":"Database_Tables/#kotobase.db.models.TatoebaSentence","title":"<code>TatoebaSentence</code>","text":"<p>               Bases: <code>Base</code></p> <p>Raw Database Tatoeba Example Sentences Table.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Row ID</p> <code>text</code> <code>Text</code> <p>The example sentence entry.</p>"},{"location":"Database_Tables/#kotobase.db.models.Base","title":"<code>Base = declarative_base()</code>  <code>module-attribute</code>","text":""},{"location":"database/","title":"Database","text":""},{"location":"database/#kotobase.db.database","title":"<code>database</code>","text":"<p>This module defines handles the database connection through the <code>get_db</code> context manager.</p>"},{"location":"database/#kotobase.db.database.get_db","title":"<code>get_db()</code>","text":"<p>Context-managed <code>SQLAlchemy</code> session providing access to the database</p> <p>Yields:</p> Name Type Description <code>Session</code> <code>Session</code> <p><code>SQLAlchemy</code> Session object.</p> <p>Raises:</p> Type Description <code>EnvironmentError</code> <p>If the <code>kotobase.db</code> file doesn't exist.</p> Source code in <code>kotobase/src/kotobase/db/database.py</code> <pre><code>@contextmanager\ndef get_db():\n    \"\"\"\n    Context-managed `SQLAlchemy` session providing access to the database\n\n    Yields:\n      Session (Session): `SQLAlchemy` Session object.\n\n    Raises:\n      EnvironmentError: If the `kotobase.db` file doesn't exist.\n    \"\"\"\n    if not DATABASE_PATH.exists():\n        raise EnvironmentError(\n            \"Couldn't find Database. Try running CLI build or pull command\")\n    new = not hasattr(_local, \"db\")\n    if new:\n        _local.db = Session(_engine(),\n                            expire_on_commit=False,\n                            autoflush=False)\n\n    try:\n        yield _local.db\n    finally:\n        if new:\n            _local.db.close()\n            del _local.db\n</code></pre>"},{"location":"database/#kotobase.db_builder.build_database","title":"<code>build_database</code>","text":"<p>This module defines the click command which builds the <code>kotobase.db</code> database using SQLAlchemy.</p>"},{"location":"database/#kotobase.db_builder.build_database.build","title":"<code>build(force)</code>","text":"<p>Downloads source files, processes, and builds the Kotobase database.</p> Source code in <code>kotobase/src/kotobase/db_builder/build_database.py</code> <pre><code>@click.command('build')\n@click.option('--force',\n              is_flag=True,\n              help=\"Force re-build even if the file exists.\"\n              )\ndef build(force):\n    \"\"\"\n    Downloads source files, processes, and builds the Kotobase database.\n    \"\"\"\n\n    if DATABASE_PATH.exists() and not force:\n        click.echo(\"Database file already exists. Use --force to re-build.\")\n        return\n    elif DATABASE_PATH.exists() and force:\n        try:\n            DATABASE_PATH.unlink()\n            click.secho(\"Deleted Old Database File\", fg=\"green\")\n\n        except FileNotFoundError:\n            click.secho(\"Database File Doesn't Exist, Remove '--force' flag.\",\n                        fg=\"red\",\n                        err=True\n                        )\n            sys.exit(1)\n        except PermissionError:\n            click.secho(\"No Permission To Delete Database File\",\n                        fg=\"red\",\n                        err=True\n                        )\n            sys.exit(1)\n        except Exception as e:\n            click.secho(\n                f\"Unexpected Error While Deleting Database File: {e}\",\n                fg=\"red\",\n                err=True\n                )\n            sys.exit(1)\n    session = Session()\n    try:\n        start = time.perf_counter()\n        click.secho(\"--- Step 1: Downloading raw data files ---\", fg=\"blue\")\n        download_data()\n\n        click.secho(\"\\n--- Step 2: Processing raw data into JSON ---\",\n                    fg=\"blue\")\n        parse_jmdict()\n        parse_jmnedict()\n        parse_kanjidic()\n        parse_tatoeba()\n\n        click.secho(\"\\n--- Step 3: Building SQLite database ---\", fg=\"blue\")\n        create_database()\n        populate_jmdict(session)\n        populate_jmnedict(session)\n        populate_kanjidic(session)\n        populate_tatoeba(session)\n        populate_jlpt(session)\n        end = time.perf_counter()\n        click.secho(\"\\nDatabase build process complete.\",\n                    fg=\"green\", bold=True)\n        build_time_sec = end - start\n        build_date = str(datetime.datetime.now())\n        build_file_size_mb = (os.path.getsize(DATABASE_PATH) / 1024) / 1024\n        build_log_txt = dedent(\n            f\"\"\"BUILD_TIME={build_time_sec}\nBUILD_DATE={build_date}\nSIZE_MB={build_file_size_mb}\n\"\"\")\n\n        # Log Build Info\n        try:\n            DB_BUILD_LOG_PATH.unlink(missing_ok=True)\n            DB_BUILD_LOG_PATH.touch()\n            DB_BUILD_LOG_PATH.write_text(build_log_txt)\n        except Exception as e:\n            click.secho(f\"Couldn't write log: {e}\",\n                        fg=\"yellow\")\n            pass\n\n        click.secho(f\"\\nBuild Time: {build_time_sec} seconds\")\n        click.secho(f\"\\nBuild Date: {build_date}\")\n        click.secho(f\"\\nFile Size: {build_file_size_mb} MB\")\n    finally:\n        # Delete Raw Files\n        for p in RAW_DATA_DIR.iterdir():\n            p.unlink(missing_ok=True)\n        # Delete JSON Files\n        JMDICT_PATH.unlink(missing_ok=True)\n        JMNEDICT_PATH.unlink(missing_ok=True)\n        KANJIDIC2_PATH.unlink(missing_ok=True)\n        TATOEBA_PATH.unlink(missing_ok=True)\n        # Close Session\n        session.close()\n</code></pre>"},{"location":"database/#kotobase.db_builder.build_database.create_database","title":"<code>create_database()</code>","text":"<p>Click command helper which creates the database and all tables.</p> Source code in <code>kotobase/src/kotobase/db_builder/build_database.py</code> <pre><code>def create_database() -&gt; None:\n    \"\"\"\n    Click command helper which creates the database and all tables.\n    \"\"\"\n    # Rebuild even when existent\n    DATABASE_PATH.unlink(missing_ok=True)\n    DATABASE_PATH.touch()\n    Base.metadata.drop_all(engine)\n    Base.metadata.create_all(engine)\n    with engine.begin() as conn:\n        conn.exec_driver_sql(\n            \"CREATE INDEX IF NOT EXISTS idx_kana_text ON jmdict_kana(text)\"\n            )\n        conn.exec_driver_sql(\n            \"CREATE INDEX IF NOT EXISTS idx_kanji_text ON jmdict_kanji(text)\"\n            )\n    click.echo(\"Database Created Successfully\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.build_database.populate_jlpt","title":"<code>populate_jlpt(session)</code>","text":"<p>Click command helper which populates JLPT tables in the database.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>SQLAlchemy Session object</p> required Source code in <code>kotobase/src/kotobase/db_builder/build_database.py</code> <pre><code>def populate_jlpt(session: SessionType) -&gt; None:\n    \"\"\"\n    Click command helper which populates JLPT tables in the database.\n\n    Args:\n      session (Session): SQLAlchemy Session object\n    \"\"\"\n\n    click.echo(\"Populating JLPT Tables ...\")\n    jlpt_dir = JLPT_FOLDER\n    json_files = list(jlpt_dir.glob(\"*.json\"))\n    level_pattern = re.compile(r'n(\\d)')\n\n    with click.progressbar(json_files,\n                           label=\"Processing JLPT Files -&gt; \"\n                           ) as bar:\n\n        for json_file in bar:\n            match = level_pattern.search(json_file.stem)\n            if not match:\n                continue\n            level = int(match.group(1))\n\n            with open(json_file, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n\n            if \"vocab\" in json_file.name:\n                for item in data:\n                    item['level'] = level\n                session.bulk_insert_mappings(JlptVocab, data)\n            elif \"kanji\" in json_file.name:\n                for item in data:\n                    item['level'] = level\n                    item['on_yomi'] = item.pop('on')\n                    item['kun_yomi'] = item.pop('kun')\n                session.bulk_insert_mappings(JlptKanji, data)\n            elif \"grammar\" in json_file.name:\n                for item in data:\n                    item['level'] = level\n                    item['examples'] = \"\\n\".join(item['examples'])\n                session.bulk_insert_mappings(JlptGrammar, data)\n\n    session.commit()\n    click.echo(\"\\nJLPT Tables Populated\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.build_database.populate_jmdict","title":"<code>populate_jmdict(session)</code>","text":"<p>Click command helper which populates JMDict tables in the database.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>SQLAlchemy Session object</p> required Source code in <code>kotobase/src/kotobase/db_builder/build_database.py</code> <pre><code>def populate_jmdict(session: SessionType) -&gt; None:\n    \"\"\"\n    Click command helper which populates JMDict tables in the database.\n\n    Args:\n      session (Session): SQLAlchemy Session object\n    \"\"\"\n    click.echo(\"Populating JMDict Tables ...\")\n    with open(JMDICT_PATH, 'r', encoding='utf-8') as f:\n        data = json.load(f)\n\n    entries = []\n    kanji_entries = []\n    kana_entries = []\n    sense_entries = []\n    seen_ids: set[int] = set()\n    with click.progressbar(data,\n                           label=\"\\nPreparing JMDict Data -&gt; \"\n                           ) as bar:\n        for item in bar:\n\n            # Skip Duplicates\n            if item['id'] in seen_ids:\n                continue\n            seen_ids.add(item['id'])\n            entries.append({'id': item['id'],\n                            'rank': item.get('rank', 99)\n                            })\n\n            # Kanji Readings\n            for k in item.get('kanji', []):\n                kanji_entries.append(\n                    {'entry_id': item['id'],\n                     'order': k.get('order', 0),\n                     'text': k['text']\n                     }\n                    )\n\n            # Kanji Readings\n            for r in item.get('kana', []):\n                kana_entries.append(\n                    {'entry_id': item['id'],\n                     'order': r.get('order', 0),\n                     'text': r['text']\n                     }\n                    )\n            # Senses\n            for s in item.get('senses', []):\n                sense_entries.append(\n                    {'entry_id': item['id'],\n                     'order': s.get('order'),\n                     'pos': \", \".join(s.get('pos', [])),\n                     'gloss': \", \".join(s.get('gloss', []))\n                     }\n                    )\n\n    click.echo(\"\\nInserting JMDict Data -&gt; \")\n    session.bulk_insert_mappings(JMDictEntry, entries)\n    session.bulk_insert_mappings(JMDictKanji, kanji_entries)\n    session.bulk_insert_mappings(JMDictKana, kana_entries)\n    session.bulk_insert_mappings(JMDictSense, sense_entries)\n    session.commit()\n    click.echo(\"\\nJMDict Tables Populated\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.build_database.populate_jmnedict","title":"<code>populate_jmnedict(session)</code>","text":"<p>Click command helper which populates JMNeDict tables in the database.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>SQLAlchemy Session object</p> required Source code in <code>kotobase/src/kotobase/db_builder/build_database.py</code> <pre><code>def populate_jmnedict(session: SessionType) -&gt; None:\n    \"\"\"\n    Click command helper which populates JMNeDict tables in the database.\n\n    Args:\n      session (Session): SQLAlchemy Session object\n    \"\"\"\n\n    click.echo(\"Populating JMnedict Table ...\")\n    with open(JMNEDICT_PATH, 'r', encoding='utf-8') as f:\n        data = json.load(f)\n\n    entries = []\n    with click.progressbar(data,\n                           label=\"\\nPreparing JMnedict Data -&gt; \"\n                           ) as bar:\n        for item in bar:\n            types = [\n                t for sublist in item['translations'] for t in sublist['type']\n                ]\n            translations = [\n                t for sublist in item[\n                    'translations'] for t in sublist['translation']\n                ]\n            entries.append(\n                {'id': item['id'],\n                 'kanji': \", \".join([k['text'] for k in item['kanji']]),\n                 'kana': \", \".join([k['text'] for k in item['kana']]),\n                 'translation_type': \", \".join(types),\n                 'translation': \", \".join(translations)\n                 }\n                )\n\n    click.echo(\"\\nInserting JMnedict Entries -&gt; \")\n    session.bulk_insert_mappings(JMnedictEntry, entries)\n    session.commit()\n    click.echo(\"\\nJMnedict Table Populated\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.build_database.populate_kanjidic","title":"<code>populate_kanjidic(session)</code>","text":"<p>Click command helper which populates KANJIDIC table in the database.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>SQLAlchemy Session object</p> required Source code in <code>kotobase/src/kotobase/db_builder/build_database.py</code> <pre><code>def populate_kanjidic(session: SessionType) -&gt; None:\n    \"\"\"\n    Click command helper which populates KANJIDIC table in the database.\n\n    Args:\n      session (Session): SQLAlchemy Session object\n    \"\"\"\n\n    click.echo(\"Populating Kanjidic Table ...\")\n    with open(KANJIDIC2_PATH, 'r', encoding='utf-8') as f:\n        data = json.load(f)\n\n    entries = []\n    with click.progressbar(data,\n                           label=\"Preparing Kanjidic Data -&gt;\"\n                           ) as bar:\n        for item in bar:\n            on_readings = [\n                r['value'] for r in item['reading_meaning']['readings']\n                if r['type'] == 'ja_on'\n                ]\n            kun_readings = [\n                r['value'] for r in item['reading_meaning']['readings']\n                if r['type'] == 'ja_kun'\n                ]\n            meanings = [\n                m['value'] for m in item['reading_meaning']['meanings']\n                if m['lang'] == 'en'\n                ]\n\n            entries.append(\n                {'literal': item['literal'],\n                 'grade': item.get('grade'),\n                 'stroke_count': (\n                     item['stroke_count'][0] if item['stroke_count'] else None\n                     ),\n                 'jlpt': item.get('jlpt'),\n                 'on_readings': \", \".join(on_readings),\n                 'kun_readings': \", \".join(kun_readings),\n                 'meanings': \", \".join(meanings)\n                 }\n                )\n\n    click.echo(\"\\nInserting Kanjidic Entries -&gt; \")\n    session.bulk_insert_mappings(Kanjidic, entries)\n    session.commit()\n    click.echo(\"\\nKanjidic Table Populated\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.build_database.populate_tatoeba","title":"<code>populate_tatoeba(session)</code>","text":"<p>Click command helper which populates Tatoeba table in the database.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>SQLAlchemy Session object</p> required Source code in <code>kotobase/src/kotobase/db_builder/build_database.py</code> <pre><code>def populate_tatoeba(session: SessionType) -&gt; None:\n    \"\"\"\n    Click command helper which populates Tatoeba table in the database.\n\n    Args:\n      session (Session): SQLAlchemy Session object\n    \"\"\"\n\n    click.echo(\"Populating Tatoeba Table ...\")\n    with open(TATOEBA_PATH, 'r', encoding='utf-8') as f:\n        data = json.load(f)\n\n    entries = []\n    with click.progressbar(data,\n                           label=\"\\nPreparing Tatoeba Data -&gt; \"\n                           ) as bar:\n        for item in bar:\n            entries.append({'id': item['id'], 'text': item['text']})\n\n    click.echo(\"\\nInserting Tatoeba Entries -&gt;\")\n    session.bulk_insert_mappings(TatoebaSentence, entries)\n    session.commit()\n    click.echo(\"Tatoeba Table Populated.\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.download","title":"<code>download</code>","text":"<p>This module defines the helper function which downloads the zipped source files and extracts their content for processing.</p>"},{"location":"database/#kotobase.db_builder.download.download_and_extract","title":"<code>download_and_extract(url, output_filename)</code>","text":"<p>Click command helper which downloads a file from an URL and extracts it if it is compressed.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>File download URL</p> required <code>output_filename</code> <code>str</code> <p>Path of where to save the file.</p> required Source code in <code>kotobase/src/kotobase/db_builder/download.py</code> <pre><code>def download_and_extract(url: str,\n                         output_filename: str\n                         ) -&gt; None:\n    \"\"\"\n    Click command helper which downloads a file\n    from an URL and extracts it if it is compressed.\n\n    Args:\n      url (str): File download URL\n      output_filename (str): Path of where to save the file.\n    \"\"\"\n    try:\n        output_path = RAW_DATA_DIR / output_filename\n        # Delete if it already exists\n        output_path.unlink(missing_ok=True)\n        click.secho(f\"Downloading '{url}' ...\",\n                    fg=\"blue\")\n        response = requests.get(url, stream=True)\n        response.raise_for_status()\n\n        with open(output_path, \"wb\") as f:\n            for chunk in response.iter_content(chunk_size=8192):\n                f.write(chunk)\n\n        click.secho(\"  Download Successful\",\n                    fg=\"green\")\n\n        # Uncompress GZ file\n        if url.endswith(\".gz\"):\n            uncompressed_path = output_path.with_suffix('')\n            # Delete if it already exists\n            uncompressed_path.unlink(missing_ok=True)\n            click.secho(f\"  Extracting to '{uncompressed_path}' ...\",\n                        fg=\"blue\")\n            with gzip.open(output_path, \"rb\") as f_in:\n                with open(uncompressed_path, \"wb\") as f_out:\n                    f_out.write(f_in.read())\n            output_path.unlink()\n            click.secho(\"  Done!\",\n                        fg=\"green\")\n\n        # Uncompress BZ2 file\n        elif url.endswith(\".bz2\"):\n            uncompressed_path = output_path.with_suffix('')\n            # Delete if it already exists\n            uncompressed_path.unlink(missing_ok=True)\n            click.secho(f\"  Extracting to '{uncompressed_path}' ...\",\n                        fg=\"blue\")\n            with bz2.open(output_path, \"rb\") as f_in:\n                with open(uncompressed_path, \"wb\") as f_out:\n                    f_out.write(f_in.read())\n            output_path.unlink()\n            click.secho(\"  Done!\",\n                        fg=\"bright_green\")\n    except Exception as e:\n        click.secho(f\"Error while downloading '{url}' : {e}\",\n                    fg=\"red\",\n                    err=True\n                    )\n        sys.exit(1)\n</code></pre>"},{"location":"database/#kotobase.db_builder.download.main","title":"<code>main()</code>","text":"<p>Main download function to download all data sources from URLs specified in the <code>config</code> module.</p> Source code in <code>kotobase/src/kotobase/db_builder/download.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Main download function to download all data sources\n    from URLs specified in the `config` module.\n    \"\"\"\n    RAW_DATA_DIR.mkdir(parents=True, exist_ok=True)\n    download_and_extract(JMDICT_URL, \"JMdict_e.xml.gz\")\n    download_and_extract(JMNEDICT_URL, \"JMnedict.xml.gz\")\n    download_and_extract(KANJIDIC2_URL, \"kanjidic2.xml.gz\")\n    download_and_extract(TATOEBA_URL, \"jpn_sentences.tsv.bz2\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.process_jmdict","title":"<code>process_jmdict</code>","text":"<p>This module defines the helper function which processes the raw JMDict XML file into a JSON file using XSLT transform for performance.</p>"},{"location":"database/#kotobase.db_builder.process_jmdict.parse_jmdict","title":"<code>parse_jmdict()</code>","text":"<p>Click helper function which parses JMdict_e.xml and saves it as a JSON file using an embedded XSLT.</p> Source code in <code>kotobase/src/kotobase/db_builder/process_jmdict.py</code> <pre><code>def parse_jmdict() -&gt; None:\n    \"\"\"\n    Click helper function which parses JMdict_e.xml\n    and saves it as a JSON file using an embedded XSLT.\n    \"\"\"\n\n    raw_path = RAW_JMDICT_PATH\n    processed_path = JMDICT_PATH\n    # Delete if it already exists\n    processed_path.unlink(missing_ok=True)\n\n    processed_path.parent.mkdir(parents=True, exist_ok=True)\n\n    click.echo(f\"Parsing '{raw_path.name}' with embedded XSLT ...\")\n\n    xml_doc = etree.parse(str(raw_path))\n    xslt_doc = etree.parse(BytesIO(XSLT_TRANSFORM))\n    transform = etree.XSLT(xslt_doc)\n\n    result_tree = transform(xml_doc)\n\n    entries = []\n    lines = str(result_tree).splitlines()\n\n    with click.progressbar(lines,\n                           label=\"Assembling JSON -&gt; \",\n                           item_show_func=lambda x: \"\") as bar:\n        for i, line in enumerate(bar):\n            parts = line.split('|')\n            if len(parts) != 5:\n                continue\n\n            entry_id, kanji_str, kana_str, pri_str, senses_str = parts\n            pri_list = [p for p in pri_str.split('~') if p]\n            entry_rank = _rank(pri_list)\n            senses = []\n            for j, sense_part in enumerate(senses_str.split('^')):\n                if not sense_part:\n                    continue\n                if ';' in sense_part:\n                    gloss_str, pos_str = sense_part.split(';', 1)\n                else:\n                    gloss_str, pos_str = sense_part, \"\"\n\n                senses.append({\n                    \"order\": j,\n                    \"gloss\": [g for g in gloss_str.split('~') if g],\n                    \"pos\": [p for p in pos_str.split('~') if p]\n                })\n\n                entries.append({\n                    \"id\": int(entry_id),\n                    \"rank\": entry_rank,\n                    \"kanji\": [\n                        {\"text\": k, \"order\": i}\n                        for i, k in enumerate(kanji_str.split('~')) if k\n                        ],\n                    \"kana\": [{\"text\": k, \"order\": i}\n                             for i, k in enumerate(kana_str.split('~')) if k\n                             ],\n                    \"senses\": senses\n                    })\n\n    click.echo(\n        f\"\\nWriting {len(entries)} entries to '{processed_path.name}' ...\"\n        )\n    with open(processed_path, 'w', encoding='utf-8') as f:\n        json.dump(entries, f, ensure_ascii=False)\n\n    click.secho(\"Successfully Processed JMDict.\", fg=\"green\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.process_jmnedict","title":"<code>process_jmnedict</code>","text":"<p>This module defines the helper function which processes the raw JMNeDict XML file into a JSON file using XSLT transform for performance.</p>"},{"location":"database/#kotobase.db_builder.process_jmnedict.parse_jmnedict","title":"<code>parse_jmnedict()</code>","text":"<p>Click helper function which parses JMNedict_e.xml and saves it as a JSON file using an embedded XSLT.</p> Source code in <code>kotobase/src/kotobase/db_builder/process_jmnedict.py</code> <pre><code>def parse_jmnedict():\n    \"\"\"\n    Click helper function which parses JMNedict_e.xml\n    and saves it as a JSON file using an embedded XSLT.\n    \"\"\"\n\n    raw_path = RAW_JMNEDICT_PATH\n    processed_path = JMNEDICT_PATH\n    # Delete if it already exists\n    processed_path.unlink(missing_ok=True)\n\n    processed_path.parent.mkdir(parents=True, exist_ok=True)\n\n    click.echo(f\"Parsing '{raw_path.name}' with embedded XSLT ...\")\n\n    # Load XML from file and XSLT from embedded string\n    xml_doc = etree.parse(str(raw_path))\n    xslt_doc = etree.parse(BytesIO(XSLT_TRANSFORM))\n    transform = etree.XSLT(xslt_doc)\n\n    # Apply transformation at C-level for speed\n    result_tree = transform(xml_doc)\n\n    # Process the simplified text output\n    entries = []\n    lines = str(result_tree).splitlines()\n\n    with click.progressbar(lines,\n                           label=\"Assembling JSON -&gt; \",\n                           item_show_func=lambda x: \"\") as bar:\n        for i, line in enumerate(bar):\n            parts = line.split('|')\n            if len(parts) != 4:\n                continue\n\n            entry_id, kanji_str, kana_str, trans_str = parts\n            translations = []\n            for trans_part in trans_str.split('^'):\n                if not trans_part:\n                    continue\n                if ';' in trans_part:\n                    type_str, detail_str = trans_part.split(';', 1)\n                else:\n                    type_str, detail_str = trans_part, \"\"\n                translations.append({\n                    \"type\": [t for t in type_str.split('~') if t],\n                    \"translation\": [d for d in detail_str.split('~') if d]\n                })\n\n            entries.append({\n                \"id\": int(entry_id),\n                \"kanji\": [{\"text\": k} for k in kanji_str.split('~') if k],\n                \"kana\": [{\"text\": k} for k in kana_str.split('~') if k],\n                \"translations\": translations\n            })\n\n    click.echo(\n        f\"\\nWriting {len(entries)} entries to '{processed_path.name}' ...\")\n    with open(processed_path, 'w', encoding='utf-8') as f:\n        json.dump(entries, f, ensure_ascii=False)\n\n    click.secho(\"Successfully Processed JMnedict.\", fg=\"green\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.process_kanjidic","title":"<code>process_kanjidic</code>","text":"<p>This module defines the helper function which processes the raw KANJIDIC2 XML file into a JSON</p>"},{"location":"database/#kotobase.db_builder.process_kanjidic.parse_kanjidic","title":"<code>parse_kanjidic()</code>","text":"<p>Click helper function which parses kanjidic.xml and saves it as a JSON file.</p> Source code in <code>kotobase/src/kotobase/db_builder/process_kanjidic.py</code> <pre><code>def parse_kanjidic() -&gt; None:\n    \"\"\"\n    Click helper function which parses kanjidic.xml\n    and saves it as a JSON file.\n    \"\"\"\n\n    raw_path = RAW_KANJIDIC2_PATH\n    processed_path = KANJIDIC2_PATH\n    # Delete if it already exists\n    processed_path.unlink(missing_ok=True)\n    processed_path.parent.mkdir(parents=True, exist_ok=True)\n\n    click.echo(f\"Parsing '{raw_path.name}' ...\")\n\n    characters = []\n    # Use iterparse for memory-efficient parsing\n    with click.progressbar(etree.iterparse(raw_path, tag='character'),\n                           label=\"Processing characters -&gt; \",\n                           item_show_func=lambda x: \"\"\n                           ) as bar:\n        for _, element in bar:\n            character = {\n                \"literal\": element.findtext('literal'),\n                \"codepoint\": [\n                    {\"type\": cp.get('cp_type'), \"value\": cp.text}\n                    for cp in element.findall('codepoint/cp_value')\n                ],\n                \"radical\": [\n                    {\"type\": rad.get('rad_type'), \"value\": rad.text}\n                    for rad in element.findall('radical/rad_value')\n                ],\n                \"grade\": element.findtext('misc/grade'),\n                \"stroke_count\": [\n                    sc.text for sc in element.findall('misc/stroke_count')],\n                \"variants\": [\n                    {\"type\": var.get('var_type'), \"value\": var.text}\n                    for var in element.findall('misc/variant')\n                ],\n                \"freq\": element.findtext('misc/freq'),\n                \"jlpt\": element.findtext('misc/jlpt'),\n                \"dic_number\": [\n                    {\"type\": dr.get('dr_type'),\n                     \"m_vol\": dr.get('m_vol'),\n                     \"m_page\": dr.get('m_page'),\n                     \"value\": dr.text}\n                    for dr in element.findall('dic_number/dic_ref')\n                ],\n                \"query_code\": [\n                    {\"type\": qc.get('qc_type'),\n                     \"skip_misclass\": qc.get('skip_misclass'),\n                     \"value\": qc.text}\n                    for qc in element.findall('query_code/q_code')\n                ],\n                \"reading_meaning\": {\n                    \"readings\": [\n                        {\"type\": r.get('r_type'),\n                         \"on_type\": r.get('on_type'),\n                         \"r_status\": r.get('r_status'),\n                         \"value\": r.text}\n                        for r in element.findall(\n                            'reading_meaning/rmgroup/reading')\n                    ],\n                    \"meanings\": [\n                        {\"lang\": m.get('m_lang', 'en'),\n                         \"value\": m.text}\n                        for m in element.findall(\n                            'reading_meaning/rmgroup/meaning')\n                    ]\n                }\n            }\n\n            characters.append(character)\n            # Free up memory\n            element.clear()\n            while element.getprevious() is not None:\n                del element.getparent()[0]\n\n    click.echo(f\"\\nWriting {len(characters)} characters\\\n        to '{processed_path.name}' ...\")\n    with open(processed_path, 'w', encoding='utf-8') as f:\n        json.dump(characters, f, ensure_ascii=False)\n\n    click.secho(\"Successfully Processed Kanjidic2.\", fg=\"green\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.process_tatoeba","title":"<code>process_tatoeba</code>","text":"<p>This module defines the helper function which processes the raw Tatoeba Examples tsv file into a JSON</p>"},{"location":"database/#kotobase.db_builder.process_tatoeba.parse_tatoeba","title":"<code>parse_tatoeba()</code>","text":"<p>Click helper function which parses tatoeba.tsv and saves it as a JSON file.</p> Source code in <code>kotobase/src/kotobase/db_builder/process_tatoeba.py</code> <pre><code>def parse_tatoeba() -&gt; None:\n    \"\"\"\n    Click helper function which parses tatoeba.tsv\n    and saves it as a JSON file.\n    \"\"\"\n    raw_path = RAW_TATOEBA_PATH\n    processed_path = TATOEBA_PATH\n    # Delete if it already exists\n    processed_path.unlink(missing_ok=True)\n    processed_path.parent.mkdir(parents=True, exist_ok=True)\n\n    click.echo(f\"Parsing {raw_path.name}...\")\n\n    sentences = []\n    with open(raw_path, 'r', encoding='utf-8') as f:\n        # Get total number of lines for progress bar\n        total_lines = sum(1 for line in f)\n        f.seek(0)\n\n        reader = csv.reader(f, delimiter='\t', quoting=csv.QUOTE_NONE)\n        with click.progressbar(reader, length=total_lines,\n                               label=\"Processing sentences -&gt; \") as bar:\n            for row in bar:\n                if len(row) == 3:\n                    sentences.append({\n                        \"id\": int(row[0]),\n                        \"lang\": row[1],\n                        \"text\": row[2]\n                    })\n\n    click.echo(f\"\\nWriting {len(sentences)} \\\n        sentences to '{processed_path.name}' ...\")\n    with open(processed_path, 'w', encoding='utf-8') as f:\n        json.dump(sentences, f, ensure_ascii=False)\n\n    click.secho(\"Successfully Processed Tatoeba Sentences.\", fg=\"green\")\n</code></pre>"},{"location":"database/#kotobase.db_builder.pull","title":"<code>pull</code>","text":"<p>This module defines the click command which pulls a pre-built database from a public Google Drive folder.</p>"},{"location":"database/#kotobase.db_builder.pull.pull_db","title":"<code>pull_db(force)</code>","text":"<p>Downloads the latest Kotobase database from Google Drive.</p> Source code in <code>kotobase/src/kotobase/db_builder/pull.py</code> <pre><code>@click.command('pull-db')\n@click.option('--force',\n              is_flag=True,\n              help=\"Force re-download even if the file exists.\"\n              )\ndef pull_db(force):\n    \"\"\"\n    Downloads the latest Kotobase database from Google Drive.\n    \"\"\"\n\n    if DATABASE_PATH.exists() and not force:\n        click.echo(\"Database file already exists. Use --force to re-download.\")\n        return\n    elif DATABASE_PATH.exists() and force:\n        try:\n            DATABASE_PATH.unlink()\n            DB_BUILD_LOG_PATH.unlink(missing_ok=True)\n            click.secho(\"Deleted Old Database File\", fg=\"green\")\n\n        except FileNotFoundError:\n            click.secho(\"Database File Doesn't Exist, Remove '--force' flag.\",\n                        fg=\"red\",\n                        err=True\n                        )\n            sys.exit(1)\n        except PermissionError:\n            click.secho(\"No Permission To Delete Database File\",\n                        fg=\"red\",\n                        err=True\n                        )\n            sys.exit(1)\n        except Exception as e:\n            click.secho(\n                f\"Unexpected Error While Deleting Database File: {e}\",\n                fg=\"red\",\n                err=True\n                )\n            sys.exit(1)\n\n    click.secho(\"Pulling Latest From Drive...\",\n                fg=\"blue\")\n\n    try:\n        # Use the file ID directly\n        gdown.download(id=DRIVE_FILE_ID,\n                       output=str(DATABASE_PATH),\n                       quiet=False)\n        click.secho(\"Pulling Build Log...\")\n        # Also pull build log\n        gdown.download(id=DRIVE_LOG_FILE_ID,\n                       output=str(DB_BUILD_LOG_PATH),\n                       quiet=False)\n        click.secho(\"Database downloaded successfully.\", fg=\"green\")\n    except Exception as e:\n        click.secho(f\"An error occurred: {e}\", fg=\"red\")\n        click.echo(\"Please try building the \\\n            database manually with 'kotobase build'.\")\n</code></pre>"},{"location":"datatypes/","title":"Datatypes","text":""},{"location":"datatypes/#kotobase.core.datatypes","title":"<code>datatypes</code>","text":"<p>This module defines the <code>kotobase</code> datatypes representing information from the different data sources.</p>"},{"location":"datatypes/#kotobase.core.datatypes.JLPTGrammarDTO","title":"<code>JLPTGrammarDTO</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A Python Dataclass object representing an entry of Tanos JLPT Grammar list.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Integer Database Entry ID.</p> required <code>level</code> <code>int</code> <p>Integer representing in which JLPT level the Entry exists.</p> required <code>grammar</code> <code>str</code> <p>String representing grammar point.</p> required <code>formation</code> <code>str</code> <p>String representing grammar point formation pattern.</p> required <code>examples</code> <code>List[str]</code> <p>List of strings containing grammar point examples.</p> <code>list()</code>"},{"location":"datatypes/#kotobase.core.datatypes.JLPTKanjiDTO","title":"<code>JLPTKanjiDTO</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A Python Dataclass object representing an entry of Tanos JLPT Kanji list.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Integer Database Entry ID.</p> required <code>level</code> <code>int</code> <p>Integer representing in which JLPT level the Entry exists.</p> required <code>kanji</code> <code>str</code> <p>String representing Entry Kanji</p> required"},{"location":"datatypes/#kotobase.core.datatypes.JLPTVocabDTO","title":"<code>JLPTVocabDTO</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A Python Dataclass object representing an entry of Tanos JLPT Vocabulary list.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Integer Database Entry ID.</p> required <code>level</code> <code>int</code> <p>Integer representing in which JLPT level the Entry exists.</p> required <code>kanji</code> <code>str</code> <p>String representing Entry Kanji</p> required <code>hiragana</code> <code>str</code> <p>String representing Entry kana reading.</p> required <code>english</code> <code>str</code> <p>String representing Entry english translation</p> required"},{"location":"datatypes/#kotobase.core.datatypes.JMDictEntryDTO","title":"<code>JMDictEntryDTO</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A Python Dataclass object representing a JMDict Entry.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Integer Database Entry ID.</p> required <code>rank</code> <code>int</code> <p>Integer priority rank of entry</p> required <code>kana</code> <code>List[str]</code> <p>List of Strings representing Kana Readings.</p> <code>list()</code> <code>kanji</code> <code>List[str]</code> <p>List of Strings representig existing Kanji in Entry.</p> <code>list()</code> <code>senses</code> <code>List[Dict[str, Any]]</code> <p>List of Dicts in format <code>{'order':int, 'pos': str, 'gloss':str}</code>       representing Entry senses.</p> <code>list()</code>"},{"location":"datatypes/#kotobase.core.datatypes.JMNeDictEntryDTO","title":"<code>JMNeDictEntryDTO</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A Python Dataclass object representing a JMNeDict Entry.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Integer Database Entry ID.</p> required <code>kana</code> <code>List[str]</code> <p>List of Strings representing Kana Readings.</p> <code>list()</code> <code>kanji</code> <code>List[str]</code> <p>List of Strings representig existing Kanji in Entry.</p> <code>list()</code> <code>translation_type</code> <code>str</code> <p>String representing type of Entry.</p> <code>''</code> <code>gloss</code> <code>List[str]</code> <p>List of strings representing glosses of Entry.</p> <code>list()</code>"},{"location":"datatypes/#kotobase.core.datatypes.KanjiDTO","title":"<code>KanjiDTO</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A Python Dataclass object representing an entry of KANJIDIC2.</p> <p>Parameters:</p> Name Type Description Default <code>literal</code> <code>str</code> <p>String of Kanji Literal</p> required <code>grade</code> <code>Optional[int]</code> <p>Optional Integer of Japanese Grade in which Kanji is learned</p> required <code>stroke_count</code> <code>int</code> <p>Integer representing number of strokes in handwriting.</p> required <code>meanings</code> <code>List[str]</code> <p>List of String representing known meanings.</p> required <code>onyomi</code> <code>List[str]</code> <p>List of strings representing on readings.</p> required <code>kunyomi</code> <code>List[str]</code> <p>List of strings representing kun readings.</p> required <code>jlpt_kanjidic</code> <code>Optional[int]</code> <p>Optional Integer representing JLPT level in KANJIDIC2</p> required <code>jlpt_tanos</code> <code>Optional[int]</code> <p>Optional Integer representing JLPT level in Tanos list.</p> required"},{"location":"datatypes/#kotobase.core.datatypes.LookupResult","title":"<code>LookupResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A Python Dataclass object which aggreates results of all database queries.</p> <p>Parameters:</p> Name Type Description Default <code>word</code> <code>str</code> <p>String of the looked up word.</p> required <code>entries</code> <code>List[JMDictEntryDTO | JMNeDictEntryDTO]</code> <p>List containing found entries in the form of JMDictEntryDTO or        JMNeDictEntryDTO objects.</p> required <code>kanji</code> <code>List[KanjiDTO]</code> <p>List containing found kanji in the form of KanjiDTO objects.</p> required <code>jlpt_vocab</code> <code>Optional[JLPTVocabDTO]</code> <p>Optional JLPTVocabDTO object.</p> required <code>jlpt_kanji_levels</code> <code>Dict[str, int]</code> <p>Dictionary with kanji levels from Tanos Lists.</p> required <code>jlpt_grammar</code> <code>List[JLPTGrammarDTO]</code> <p>List of JLPTGrammarDTO objects.</p> required <code>examples</code> <code>List[SentenceDTO]</code> <p>List of SentenceDTO objects.</p> required"},{"location":"datatypes/#kotobase.core.datatypes.LookupResult.filter_entries","title":"<code>filter_entries()</code>","text":"<p>Convenience function for splitting entries between JMDictEntryDTO and JMNeDictEntryDTO</p> <p>Returns:</p> Type Description <code>Dict[str, list]</code> <p>Dict[str, list]: Split entries dictionary of format                <code>{'jmdict': list, 'jmnedict': list}</code></p>"},{"location":"datatypes/#kotobase.core.datatypes.LookupResult.has_jlpt","title":"<code>has_jlpt()</code>","text":"<p>Convenience function for checking if the result contains JLPT information</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if JLPT is present, False otherwise</p>"},{"location":"datatypes/#kotobase.core.datatypes.SentenceDTO","title":"<code>SentenceDTO</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A Python Dataclass object representing an example sentence from the Tatoeba project.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Integer Database Entry ID.</p> required <code>text</code> <code>str</code> <p>String of example.</p> required"},{"location":"datatypes/#kotobase.core.datatypes.Serializable","title":"<code>Serializable</code>","text":"<p>Base class for adding <code>to_dict</code> and <code>to_json</code> methods for all dataclasses.</p>"},{"location":"datatypes/#kotobase.core.datatypes.Serializable.to_dict","title":"<code>to_dict()</code>","text":"<p>Return DTO as a python dictionary by calling <code>asdict</code> on dataclass</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: DTO information as a python dict</p>"},{"location":"datatypes/#kotobase.core.datatypes.Serializable.to_json","title":"<code>to_json(**json_kwargs)</code>","text":"<p>Return DTO in json format by calling <code>json.dumps</code> on the <code>to_dict</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>**json_kwargs</code> <code>dict</code> <p>Keyword arguments for <code>json.dumps</code></p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The object in JSON string format</p>"},{"location":"repos/","title":"Repos","text":""},{"location":"repos/#kotobase.repos.jlpt","title":"<code>jlpt</code>","text":"<p>This module defines the <code>JLPTRepo</code> class used for querying data extracted from Jonathan Weller's website in the database.</p>"},{"location":"repos/#kotobase.repos.jlpt.JLPTRepo","title":"<code>JLPTRepo</code>","text":"<p>Query JLPT Related Tables of Database</p> Source code in <code>kotobase/src/kotobase/repos/jlpt.py</code> <pre><code>class JLPTRepo:\n    \"\"\"\n    Query JLPT Related Tables of Database\n    \"\"\"\n\n    # \u2500\u2500 vocab \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    @staticmethod\n    @lru_cache(maxsize=30_000)\n    def vocab_by_word(word: str) -&gt; Optional[dt.JLPTVocabDTO]:\n        \"\"\"\n        Get vocabulary by word\n\n        Args:\n          word (str): Word to query\n\n        Returns:\n          JLPTVocabDTO: JLPT Vocab data object.\n        \"\"\"\n        with get_db() as s:\n            row = (\n                s.query(orm.JlptVocab)\n                .filter(\n                    (orm.JlptVocab.kanji == word\n                     ) | (orm.JlptVocab.hiragana == word))\n                .first()\n            )\n        return dt.map_jlpt_vocab(row) if row else None\n\n    @staticmethod\n    def vocab_level(word: str) -&gt; Optional[int]:\n        \"\"\"\n        Get Vocab JLPT levels\n\n        Args:\n          word (str): Word to query.\n\n        Returns:\n          int: JLPT level if existent.\n        \"\"\"\n        dto = JLPTRepo.vocab_by_word(word)\n        return dto.level if dto else None\n\n    # Kanji Levels\n\n    @staticmethod\n    def kanji_levels(chars: Iterable[str]) -&gt; Dict[str, int]:\n        \"\"\"\n        Get Kanji levels with bulk search\n\n        Args:\n          chars (Iterable[str]): Iterable of character to query.\n\n        Returns:\n          Dict[str, int]: Dictionary with character keys and level values.\n        \"\"\"\n        with get_db() as s:\n            rows = (\n                s.query(orm.JlptKanji)\n                .filter(orm.JlptKanji.kanji.in_(chars))\n                .all()\n            )\n        return {r.kanji: r.level for r in rows}\n\n    # Grammar Lookup\n\n    @staticmethod\n    def grammar_entries_like(pattern: str) -&gt; List[dt.JLPTGrammarDTO]:\n        \"\"\"\n        Wildcard search for grammar patterns\n\n        Args:\n          pattern (str): Wildcard Pattern\n\n        Returns:\n          List[JLPTGrammarDTO]: List of JLPT Grammar data objects.\n        \"\"\"\n        pattern = pattern.replace(\"\uff5e\", \"%\").replace(\"*\", \"%\")\n        with get_db() as s:\n            rows = (\n                s.query(orm.JlptGrammar)\n                .filter(\n                    orm.JlptGrammar.grammar.like(f\"{pattern}%\", escape=\"\\\\\"))\n                .all()\n            )\n        return dt.map_many(dt.map_jlpt_grammar, rows)\n</code></pre>"},{"location":"repos/#kotobase.repos.jlpt.JLPTRepo.grammar_entries_like","title":"<code>grammar_entries_like(pattern)</code>  <code>staticmethod</code>","text":"<p>Wildcard search for grammar patterns</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Wildcard Pattern</p> required <p>Returns:</p> Type Description <code>List[JLPTGrammarDTO]</code> <p>List[JLPTGrammarDTO]: List of JLPT Grammar data objects.</p> Source code in <code>kotobase/src/kotobase/repos/jlpt.py</code> <pre><code>@staticmethod\ndef grammar_entries_like(pattern: str) -&gt; List[dt.JLPTGrammarDTO]:\n    \"\"\"\n    Wildcard search for grammar patterns\n\n    Args:\n      pattern (str): Wildcard Pattern\n\n    Returns:\n      List[JLPTGrammarDTO]: List of JLPT Grammar data objects.\n    \"\"\"\n    pattern = pattern.replace(\"\uff5e\", \"%\").replace(\"*\", \"%\")\n    with get_db() as s:\n        rows = (\n            s.query(orm.JlptGrammar)\n            .filter(\n                orm.JlptGrammar.grammar.like(f\"{pattern}%\", escape=\"\\\\\"))\n            .all()\n        )\n    return dt.map_many(dt.map_jlpt_grammar, rows)\n</code></pre>"},{"location":"repos/#kotobase.repos.jlpt.JLPTRepo.kanji_levels","title":"<code>kanji_levels(chars)</code>  <code>staticmethod</code>","text":"<p>Get Kanji levels with bulk search</p> <p>Parameters:</p> Name Type Description Default <code>chars</code> <code>Iterable[str]</code> <p>Iterable of character to query.</p> required <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: Dictionary with character keys and level values.</p> Source code in <code>kotobase/src/kotobase/repos/jlpt.py</code> <pre><code>@staticmethod\ndef kanji_levels(chars: Iterable[str]) -&gt; Dict[str, int]:\n    \"\"\"\n    Get Kanji levels with bulk search\n\n    Args:\n      chars (Iterable[str]): Iterable of character to query.\n\n    Returns:\n      Dict[str, int]: Dictionary with character keys and level values.\n    \"\"\"\n    with get_db() as s:\n        rows = (\n            s.query(orm.JlptKanji)\n            .filter(orm.JlptKanji.kanji.in_(chars))\n            .all()\n        )\n    return {r.kanji: r.level for r in rows}\n</code></pre>"},{"location":"repos/#kotobase.repos.jlpt.JLPTRepo.vocab_by_word","title":"<code>vocab_by_word(word)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Get vocabulary by word</p> <p>Parameters:</p> Name Type Description Default <code>word</code> <code>str</code> <p>Word to query</p> required <p>Returns:</p> Name Type Description <code>JLPTVocabDTO</code> <code>Optional[JLPTVocabDTO]</code> <p>JLPT Vocab data object.</p> Source code in <code>kotobase/src/kotobase/repos/jlpt.py</code> <pre><code>@staticmethod\n@lru_cache(maxsize=30_000)\ndef vocab_by_word(word: str) -&gt; Optional[dt.JLPTVocabDTO]:\n    \"\"\"\n    Get vocabulary by word\n\n    Args:\n      word (str): Word to query\n\n    Returns:\n      JLPTVocabDTO: JLPT Vocab data object.\n    \"\"\"\n    with get_db() as s:\n        row = (\n            s.query(orm.JlptVocab)\n            .filter(\n                (orm.JlptVocab.kanji == word\n                 ) | (orm.JlptVocab.hiragana == word))\n            .first()\n        )\n    return dt.map_jlpt_vocab(row) if row else None\n</code></pre>"},{"location":"repos/#kotobase.repos.jlpt.JLPTRepo.vocab_level","title":"<code>vocab_level(word)</code>  <code>staticmethod</code>","text":"<p>Get Vocab JLPT levels</p> <p>Parameters:</p> Name Type Description Default <code>word</code> <code>str</code> <p>Word to query.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>Optional[int]</code> <p>JLPT level if existent.</p> Source code in <code>kotobase/src/kotobase/repos/jlpt.py</code> <pre><code>@staticmethod\ndef vocab_level(word: str) -&gt; Optional[int]:\n    \"\"\"\n    Get Vocab JLPT levels\n\n    Args:\n      word (str): Word to query.\n\n    Returns:\n      int: JLPT level if existent.\n    \"\"\"\n    dto = JLPTRepo.vocab_by_word(word)\n    return dto.level if dto else None\n</code></pre>"},{"location":"repos/#kotobase.repos.jmdict","title":"<code>jmdict</code>","text":"<p>This module defines the <code>JMDictRepo</code> class used for querying data extracted from the JMDict XML file in the database.</p>"},{"location":"repos/#kotobase.repos.jmdict.JMDictRepo","title":"<code>JMDictRepo</code>","text":"<p>Queries JMDict Related Tables of Database</p> Source code in <code>kotobase/src/kotobase/repos/jmdict.py</code> <pre><code>class JMDictRepo:\n    \"\"\"\n    Queries JMDict Related Tables of Database\n    \"\"\"\n\n    # \u2500\u2500 single-row lookups \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    @staticmethod\n    @lru_cache(maxsize=100_000)\n    def by_id(entry_id: int) -&gt; Optional[dt.JMDictEntryDTO]:\n        \"\"\"\n        Retrieve Entry by id.\n\n        Args:\n          entry_id (int): Entry ID in database.\n\n        Returns:\n          JMDictEntryDTO: JMDict Entry Data Object.\n        \"\"\"\n        with get_db() as s:\n            row = s.get(\n                orm.JMDictEntry,\n                entry_id,\n                options=(\n                    joinedload(orm.JMDictEntry.kana),\n                    joinedload(orm.JMDictEntry.kanji),\n                    joinedload(orm.JMDictEntry.senses),\n                ),\n            )\n        return dt.map_jmdict(row) if row else None\n\n    # \u2500\u2500 search helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    @staticmethod\n    @lru_cache(maxsize=100_000)\n    def search_form(form: str,\n                    /,\n                    *,\n                    wildcard: bool = False,\n                    limit: Optional[int] = 50\n                    ) -&gt; List[dt.JMDictEntryDTO]:\n        \"\"\"\n        Exact or wildcard search across `kana` and `kanji`.\n\n        Args:\n          form (str): Query string.\n\n          wildcard (bool): If true, treat `*` and `%` and wildcards and perform\n                           a LIKE search. If false, pass wildcards unchanged\n                           and perform a simple comparison search.\n\n          limit (int, optional): Limit of entries to return, can be set to\n                                 `None` for no limit.\n        Returns:\n          List[JMDictEntryDTO]: List of JMDictEntry data objects.\n        \"\"\"\n        if wildcard:\n            pattern = form.replace(\"*\", \"%\")\n            comparator_kana = orm.JMDictKana.text.like(pattern)\n            comparator_kanji = orm.JMDictKanji.text.like(pattern)\n        else:\n            pattern = form\n            comparator_kana = orm.JMDictKana.text == form\n            comparator_kanji = orm.JMDictKanji.text == form\n\n        with get_db() as s:\n            rows = (\n                s.query(orm.JMDictEntry)\n                .filter(\n                    orm.JMDictEntry.kana.any(comparator_kana) |\n                    orm.JMDictEntry.kanji.any(comparator_kanji)\n                )\n                .options(\n                    selectinload(orm.JMDictEntry.kana),\n                    selectinload(orm.JMDictEntry.kanji),\n                    selectinload(orm.JMDictEntry.senses),\n                )\n                .order_by(orm.JMDictEntry.rank,\n                          orm.JMDictEntry.id\n                          )\n                .limit(limit)\n                .all()\n            )\n            return dt.map_many(dt.map_jmdict, rows)\n</code></pre>"},{"location":"repos/#kotobase.repos.jmdict.JMDictRepo.by_id","title":"<code>by_id(entry_id)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Retrieve Entry by id.</p> <p>Parameters:</p> Name Type Description Default <code>entry_id</code> <code>int</code> <p>Entry ID in database.</p> required <p>Returns:</p> Name Type Description <code>JMDictEntryDTO</code> <code>Optional[JMDictEntryDTO]</code> <p>JMDict Entry Data Object.</p> Source code in <code>kotobase/src/kotobase/repos/jmdict.py</code> <pre><code>@staticmethod\n@lru_cache(maxsize=100_000)\ndef by_id(entry_id: int) -&gt; Optional[dt.JMDictEntryDTO]:\n    \"\"\"\n    Retrieve Entry by id.\n\n    Args:\n      entry_id (int): Entry ID in database.\n\n    Returns:\n      JMDictEntryDTO: JMDict Entry Data Object.\n    \"\"\"\n    with get_db() as s:\n        row = s.get(\n            orm.JMDictEntry,\n            entry_id,\n            options=(\n                joinedload(orm.JMDictEntry.kana),\n                joinedload(orm.JMDictEntry.kanji),\n                joinedload(orm.JMDictEntry.senses),\n            ),\n        )\n    return dt.map_jmdict(row) if row else None\n</code></pre>"},{"location":"repos/#kotobase.repos.jmdict.JMDictRepo.search_form","title":"<code>search_form(form, /, *, wildcard=False, limit=50)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Exact or wildcard search across <code>kana</code> and <code>kanji</code>.</p> <p>Parameters:</p> Name Type Description Default <code>form</code> <code>str</code> <p>Query string.</p> required <code>wildcard</code> <code>bool</code> <p>If true, treat <code>*</code> and <code>%</code> and wildcards and perform                a LIKE search. If false, pass wildcards unchanged                and perform a simple comparison search.</p> <code>False</code> <code>limit</code> <code>int</code> <p>Limit of entries to return, can be set to                      <code>None</code> for no limit.</p> <code>50</code> <p>Returns:   List[JMDictEntryDTO]: List of JMDictEntry data objects.</p> Source code in <code>kotobase/src/kotobase/repos/jmdict.py</code> <pre><code>@staticmethod\n@lru_cache(maxsize=100_000)\ndef search_form(form: str,\n                /,\n                *,\n                wildcard: bool = False,\n                limit: Optional[int] = 50\n                ) -&gt; List[dt.JMDictEntryDTO]:\n    \"\"\"\n    Exact or wildcard search across `kana` and `kanji`.\n\n    Args:\n      form (str): Query string.\n\n      wildcard (bool): If true, treat `*` and `%` and wildcards and perform\n                       a LIKE search. If false, pass wildcards unchanged\n                       and perform a simple comparison search.\n\n      limit (int, optional): Limit of entries to return, can be set to\n                             `None` for no limit.\n    Returns:\n      List[JMDictEntryDTO]: List of JMDictEntry data objects.\n    \"\"\"\n    if wildcard:\n        pattern = form.replace(\"*\", \"%\")\n        comparator_kana = orm.JMDictKana.text.like(pattern)\n        comparator_kanji = orm.JMDictKanji.text.like(pattern)\n    else:\n        pattern = form\n        comparator_kana = orm.JMDictKana.text == form\n        comparator_kanji = orm.JMDictKanji.text == form\n\n    with get_db() as s:\n        rows = (\n            s.query(orm.JMDictEntry)\n            .filter(\n                orm.JMDictEntry.kana.any(comparator_kana) |\n                orm.JMDictEntry.kanji.any(comparator_kanji)\n            )\n            .options(\n                selectinload(orm.JMDictEntry.kana),\n                selectinload(orm.JMDictEntry.kanji),\n                selectinload(orm.JMDictEntry.senses),\n            )\n            .order_by(orm.JMDictEntry.rank,\n                      orm.JMDictEntry.id\n                      )\n            .limit(limit)\n            .all()\n        )\n        return dt.map_many(dt.map_jmdict, rows)\n</code></pre>"},{"location":"repos/#kotobase.repos.jmnedict","title":"<code>jmnedict</code>","text":"<p>This module defines the <code>JMneDictRepo</code> class used for querying data extracted from the JMneDict XML file in the database.</p>"},{"location":"repos/#kotobase.repos.jmnedict.JMNeDictRepo","title":"<code>JMNeDictRepo</code>","text":"<p>Queries related to JMNeDict Tables of the database.</p> Source code in <code>kotobase/src/kotobase/repos/jmnedict.py</code> <pre><code>class JMNeDictRepo:\n    \"\"\"\n    Queries related to JMNeDict Tables of the database.\n    \"\"\"\n\n    @staticmethod\n    @lru_cache(maxsize=40_000)\n    def by_id(entry_id: int) -&gt; Optional[dt.JMNeDictEntryDTO]:\n        \"\"\"\n        Retrieve Entry by id.\n\n        Args:\n          entry_id (int): Entry ID in database.\n\n        Returns:\n          JMNeDictEntryDTO: JMNeDict Entry Data Object.\n        \"\"\"\n        with get_db() as s:\n            row = s.get(orm.JMnedictEntry, entry_id)\n        return dt.map_jmnedict(row) if row else None\n\n    @staticmethod\n    @lru_cache(maxsize=40_000)\n    def search(form: str,\n               limit: Optional[int] = 50\n               ) -&gt; List[dt.JMNeDictEntryDTO]:\n        \"\"\"\n        LIKE search on JMNeDict table.\n\n        Args:\n          form (str): Query string.\n\n          limit (int, optional): Limit of entries to return, can be set to\n                                 `None` for no limit.\n        Returns:\n          List[JMNeDictEntryDTO]: List of JMNeDictEntry data objects.\n        \"\"\"\n        pattern = form.replace(\"*\", \"%\")\n        with get_db() as s:\n            stmt = (\n                select(orm.JMnedictEntry)\n                .where(\n                    or_(\n                        orm.JMnedictEntry.kana.like(pattern),\n                        orm.JMnedictEntry.kanji.like(pattern)\n                    )\n                )\n            )\n            if limit:\n                stmt = stmt.limit(limit)\n            rows = s.scalars(stmt).all()\n        return dt.map_many(dt.map_jmnedict, rows)\n</code></pre>"},{"location":"repos/#kotobase.repos.jmnedict.JMNeDictRepo.by_id","title":"<code>by_id(entry_id)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Retrieve Entry by id.</p> <p>Parameters:</p> Name Type Description Default <code>entry_id</code> <code>int</code> <p>Entry ID in database.</p> required <p>Returns:</p> Name Type Description <code>JMNeDictEntryDTO</code> <code>Optional[JMNeDictEntryDTO]</code> <p>JMNeDict Entry Data Object.</p> Source code in <code>kotobase/src/kotobase/repos/jmnedict.py</code> <pre><code>@staticmethod\n@lru_cache(maxsize=40_000)\ndef by_id(entry_id: int) -&gt; Optional[dt.JMNeDictEntryDTO]:\n    \"\"\"\n    Retrieve Entry by id.\n\n    Args:\n      entry_id (int): Entry ID in database.\n\n    Returns:\n      JMNeDictEntryDTO: JMNeDict Entry Data Object.\n    \"\"\"\n    with get_db() as s:\n        row = s.get(orm.JMnedictEntry, entry_id)\n    return dt.map_jmnedict(row) if row else None\n</code></pre>"},{"location":"repos/#kotobase.repos.jmnedict.JMNeDictRepo.search","title":"<code>search(form, limit=50)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>LIKE search on JMNeDict table.</p> <p>Parameters:</p> Name Type Description Default <code>form</code> <code>str</code> <p>Query string.</p> required <code>limit</code> <code>int</code> <p>Limit of entries to return, can be set to                      <code>None</code> for no limit.</p> <code>50</code> <p>Returns:   List[JMNeDictEntryDTO]: List of JMNeDictEntry data objects.</p> Source code in <code>kotobase/src/kotobase/repos/jmnedict.py</code> <pre><code>@staticmethod\n@lru_cache(maxsize=40_000)\ndef search(form: str,\n           limit: Optional[int] = 50\n           ) -&gt; List[dt.JMNeDictEntryDTO]:\n    \"\"\"\n    LIKE search on JMNeDict table.\n\n    Args:\n      form (str): Query string.\n\n      limit (int, optional): Limit of entries to return, can be set to\n                             `None` for no limit.\n    Returns:\n      List[JMNeDictEntryDTO]: List of JMNeDictEntry data objects.\n    \"\"\"\n    pattern = form.replace(\"*\", \"%\")\n    with get_db() as s:\n        stmt = (\n            select(orm.JMnedictEntry)\n            .where(\n                or_(\n                    orm.JMnedictEntry.kana.like(pattern),\n                    orm.JMnedictEntry.kanji.like(pattern)\n                )\n            )\n        )\n        if limit:\n            stmt = stmt.limit(limit)\n        rows = s.scalars(stmt).all()\n    return dt.map_many(dt.map_jmnedict, rows)\n</code></pre>"},{"location":"repos/#kotobase.repos.kanji","title":"<code>kanji</code>","text":"<p>This module defines the <code>KanjiRepo</code> class used for querying data extracted from the KANJIDIC2 XML file in the database.</p>"},{"location":"repos/#kotobase.repos.kanji.KanjiRepo","title":"<code>KanjiRepo</code>","text":"<p>Queries Kanji related Tables of the database</p> Source code in <code>kotobase/src/kotobase/repos/kanji.py</code> <pre><code>class KanjiRepo:\n    \"\"\"\n    Queries Kanji related Tables of the database\n    \"\"\"\n\n    _cache: Dict[str, dt.KanjiDTO] = {}  # caches: literal \u2192 DTO\n\n    @staticmethod\n    def by_literal(lit: str) -&gt; Optional[dt.KanjiDTO]:\n        \"\"\"\n        Retrieve Kanji by literal.\n\n        Args:\n          lit (str): The Kanji Literal\n\n        Returns:\n          KanjiDTO: Kanji Data Object\n\n        \"\"\"\n        if lit in KanjiRepo._cache:\n            return KanjiRepo._cache[lit]\n\n        with get_db() as s:\n            row = s.get(orm.Kanjidic, lit)\n            if not row:\n                return None\n\n            jlpt_row = (\n                s.query(orm.JlptKanji)\n                .filter(orm.JlptKanji.kanji == lit)\n                .first()\n            )\n            dto = dt.map_kanjidic(\n                row, jlpt_tanos_level=jlpt_row.level if jlpt_row else None\n            )\n            KanjiRepo._cache[lit] = dto\n            return dto\n\n    @staticmethod\n    def bulk_fetch(chars: Iterable[str]) -&gt; List[dt.KanjiDTO]:\n        \"\"\"\n        Bulk-Fetch Kanji for performance.\n\n        Args:\n          chars (Iterable[str]): Iterable of kanjis.\n\n        Returns:\n          List[KanjiDTO]: List of Kanji Data Objects.\n\n        \"\"\"\n        out: List[dt.KanjiDTO] = []\n        missing: List[str] = []\n        for c in chars:\n            cached = KanjiRepo._cache.get(c)\n            if cached:\n                out.append(cached)\n            else:\n                missing.append(c)\n\n        if missing:\n            with get_db() as s:\n                rows = (\n                    s.query(orm.Kanjidic)\n                    .filter(orm.Kanjidic.literal.in_(missing))\n                    .all()\n                )\n                jlpt_map = {\n                    r.kanji: r.level\n                    for r in s.query(orm.JlptKanji)\n                    .filter(orm.JlptKanji.kanji.in_(missing))\n                    .all()\n                }\n            for r in rows:\n                dto = dt.map_kanjidic(\n                    r, jlpt_tanos_level=jlpt_map.get(r.literal)\n                )\n                KanjiRepo._cache[r.literal] = dto\n                out.append(dto)\n\n        # preserve original order\n        ordering = {c: i for i, c in enumerate(chars)}\n        out.sort(key=lambda k: ordering[k.literal])\n        return out\n</code></pre>"},{"location":"repos/#kotobase.repos.kanji.KanjiRepo.bulk_fetch","title":"<code>bulk_fetch(chars)</code>  <code>staticmethod</code>","text":"<p>Bulk-Fetch Kanji for performance.</p> <p>Parameters:</p> Name Type Description Default <code>chars</code> <code>Iterable[str]</code> <p>Iterable of kanjis.</p> required <p>Returns:</p> Type Description <code>List[KanjiDTO]</code> <p>List[KanjiDTO]: List of Kanji Data Objects.</p> Source code in <code>kotobase/src/kotobase/repos/kanji.py</code> <pre><code>@staticmethod\ndef bulk_fetch(chars: Iterable[str]) -&gt; List[dt.KanjiDTO]:\n    \"\"\"\n    Bulk-Fetch Kanji for performance.\n\n    Args:\n      chars (Iterable[str]): Iterable of kanjis.\n\n    Returns:\n      List[KanjiDTO]: List of Kanji Data Objects.\n\n    \"\"\"\n    out: List[dt.KanjiDTO] = []\n    missing: List[str] = []\n    for c in chars:\n        cached = KanjiRepo._cache.get(c)\n        if cached:\n            out.append(cached)\n        else:\n            missing.append(c)\n\n    if missing:\n        with get_db() as s:\n            rows = (\n                s.query(orm.Kanjidic)\n                .filter(orm.Kanjidic.literal.in_(missing))\n                .all()\n            )\n            jlpt_map = {\n                r.kanji: r.level\n                for r in s.query(orm.JlptKanji)\n                .filter(orm.JlptKanji.kanji.in_(missing))\n                .all()\n            }\n        for r in rows:\n            dto = dt.map_kanjidic(\n                r, jlpt_tanos_level=jlpt_map.get(r.literal)\n            )\n            KanjiRepo._cache[r.literal] = dto\n            out.append(dto)\n\n    # preserve original order\n    ordering = {c: i for i, c in enumerate(chars)}\n    out.sort(key=lambda k: ordering[k.literal])\n    return out\n</code></pre>"},{"location":"repos/#kotobase.repos.kanji.KanjiRepo.by_literal","title":"<code>by_literal(lit)</code>  <code>staticmethod</code>","text":"<p>Retrieve Kanji by literal.</p> <p>Parameters:</p> Name Type Description Default <code>lit</code> <code>str</code> <p>The Kanji Literal</p> required <p>Returns:</p> Name Type Description <code>KanjiDTO</code> <code>Optional[KanjiDTO]</code> <p>Kanji Data Object</p> Source code in <code>kotobase/src/kotobase/repos/kanji.py</code> <pre><code>@staticmethod\ndef by_literal(lit: str) -&gt; Optional[dt.KanjiDTO]:\n    \"\"\"\n    Retrieve Kanji by literal.\n\n    Args:\n      lit (str): The Kanji Literal\n\n    Returns:\n      KanjiDTO: Kanji Data Object\n\n    \"\"\"\n    if lit in KanjiRepo._cache:\n        return KanjiRepo._cache[lit]\n\n    with get_db() as s:\n        row = s.get(orm.Kanjidic, lit)\n        if not row:\n            return None\n\n        jlpt_row = (\n            s.query(orm.JlptKanji)\n            .filter(orm.JlptKanji.kanji == lit)\n            .first()\n        )\n        dto = dt.map_kanjidic(\n            row, jlpt_tanos_level=jlpt_row.level if jlpt_row else None\n        )\n        KanjiRepo._cache[lit] = dto\n        return dto\n</code></pre>"},{"location":"repos/#kotobase.repos.sentences","title":"<code>sentences</code>","text":"<p>This module defines the <code>SentenceRepo</code> class used for querying data extracted from the Japanese Tatoeba example sentences in the database.</p>"},{"location":"repos/#kotobase.repos.sentences.SentenceRepo","title":"<code>SentenceRepo</code>","text":"<p>Query database for Tatoeba example senteces Tables.</p> Source code in <code>kotobase/src/kotobase/repos/sentences.py</code> <pre><code>class SentenceRepo:\n    \"\"\"\n    Query database for Tatoeba example senteces Tables.\n    \"\"\"\n\n    @staticmethod\n    def search_containing(\n        text: str,\n        /,\n        limit: int = 50,\n        wildcard: bool = False,\n    ) -&gt; List[dt.SentenceDTO]:\n        \"\"\"\n        Basic LIKE search.  If `wildcard=True` every non-space char is wrapped\n        in '%' to simulate a *contains all chars in order* fuzzy search.\n\n        Args:\n          text (str): Text to look for in sentences\n\n          limit (int): Limit how many sentences are returned.\n\n          wildcard (bool): If True every non-space char is wrapped\n                           in '%' to simulate a `contains all chars in order`\n                           fuzzy search.\n\n        Returns:\n          List[SentenceDTO]: List of Sentence data objects.\n        \"\"\"\n        if wildcard:\n            text = text.replace(\"*\", \"%\")\n            text = '%'.join(text)\n\n        pattern = f\"%{text}%\"\n\n        with get_db() as s:\n            rows = (\n                s.query(orm.TatoebaSentence)\n                .filter(orm.TatoebaSentence.text.like(pattern, escape=\"\\\\\"))\n                .limit(limit)\n                .all()\n            )\n        return dt.map_many(dt.map_sentence, rows)\n</code></pre>"},{"location":"repos/#kotobase.repos.sentences.SentenceRepo.search_containing","title":"<code>search_containing(text, /, limit=50, wildcard=False)</code>  <code>staticmethod</code>","text":"<p>Basic LIKE search.  If <code>wildcard=True</code> every non-space char is wrapped in '%' to simulate a contains all chars in order fuzzy search.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to look for in sentences</p> required <code>limit</code> <code>int</code> <p>Limit how many sentences are returned.</p> <code>50</code> <code>wildcard</code> <code>bool</code> <p>If True every non-space char is wrapped                in '%' to simulate a <code>contains all chars in order</code>                fuzzy search.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[SentenceDTO]</code> <p>List[SentenceDTO]: List of Sentence data objects.</p> Source code in <code>kotobase/src/kotobase/repos/sentences.py</code> <pre><code>@staticmethod\ndef search_containing(\n    text: str,\n    /,\n    limit: int = 50,\n    wildcard: bool = False,\n) -&gt; List[dt.SentenceDTO]:\n    \"\"\"\n    Basic LIKE search.  If `wildcard=True` every non-space char is wrapped\n    in '%' to simulate a *contains all chars in order* fuzzy search.\n\n    Args:\n      text (str): Text to look for in sentences\n\n      limit (int): Limit how many sentences are returned.\n\n      wildcard (bool): If True every non-space char is wrapped\n                       in '%' to simulate a `contains all chars in order`\n                       fuzzy search.\n\n    Returns:\n      List[SentenceDTO]: List of Sentence data objects.\n    \"\"\"\n    if wildcard:\n        text = text.replace(\"*\", \"%\")\n        text = '%'.join(text)\n\n    pattern = f\"%{text}%\"\n\n    with get_db() as s:\n        rows = (\n            s.query(orm.TatoebaSentence)\n            .filter(orm.TatoebaSentence.text.like(pattern, escape=\"\\\\\"))\n            .limit(limit)\n            .all()\n        )\n    return dt.map_many(dt.map_sentence, rows)\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#python-api-usage","title":"Python API Usage","text":"<p>Example Python Usage</p> <pre><code>from kotobase import Kotobase\n\nkb = Kotobase()\n\n# Comprehensive lookup\nresult = kb.lookup(\"\u65e5\u672c\u8a9e\")\nprint(result.to_json())\n\n# Get info for a single kanji\nkanji_info = kb.kanji(\"\u8a9e\")\nprint(kanji_info)\n\n# Get example sentences\nsentences = kb.sentences(\"\u52c9\u5f37\")\nfor sentence in sentences:\n    print(sentence.text)\n</code></pre>"}]}